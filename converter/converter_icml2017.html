<html>
<script src="../bower_components/pouchdb/dist/pouchdb.min.js"></script>
<script>
var sessionsDb = new PouchDB('https://icml.papro.org.uk/couchdb/schedule_icml2017');
var itemsDb = new PouchDB('https://icml.papro.org.uk/couchdb/papers_icml2017');
//var authorsDb = new PouchDB('https://icml.papro.org.uk/couchdb/authors');
var scheduleDb = new PouchDB('https://icml.papro.org.uk/couchdb/schedule');

var allSessionDocs;
// 1 array for each day - Monday, Tuesday, Wednesday
var sessions = [ [], [], [] ];
var sessionIdToIndexMapping = {};
var dailySchedule = [ {"dayString":"Monday", "slots":[]}, {"dayString":"Tuesday", "slots":[]}, {"dayString":"Wednesday", "slots":[]} ];
var items = {};
var types = [];
//var people = {};

//put the session in the correct timeslot
function sortSession(session, dayIndex) {
  start_time = new Date(session.session_time);
  selectedDaySessionsArray = sessions[dayIndex];

  placed = false;
  for(var i=0; i<selectedDaySessionsArray.length; ++i) {
    //access the first talk of the first item of the current Monday timegroup
    start_time_t = new Date(selectedDaySessionsArray[i][0].session_time);
    if(start_time.getTime() == start_time_t.getTime()) {
      selectedDaySessionsArray[i].push(session);
      placed = true;
      break;
    }
  }
  if(!placed) {
    newTimeGroup = [ session ];
    selectedDaySessionsArray.push(newTimeGroup);
  }
}

function getFormattedHourMinute(date) {
  var hh = date.getHours();
  var mm = date.getMinutes();
  // These lines ensure you have two-digits
  if (hh < 10) {hh = "0"+hh;}
  if (mm < 10) {mm = "0"+mm;}
  // This formats your string to HH:MM:SS
  var t = hh+":"+mm;
  return t;
}

function getSessionsTimeString(session) {
  start_time = new Date(session.talks[0].session_time)
  end_time = new Date(session.talks[session.talks.length-1].session_time)
  start_time_formatted = getFormattedHourMinute(start_time);
  end_time_formatted = getFormattedHourMinute(end_time);

  return start_time_formatted + " - " + end_time_formatted;
}

sessionsDb.allDocs({
    include_docs: true,
    attachments: true
  }).then(function (result) {
    allSessionDocs = result.rows;

    // Put the sessions into Daily slots
    for(var sessDoc_index=0; sessDoc_index<allSessionDocs.length; ++sessDoc_index){
      t_doc = allSessionDocs[sessDoc_index].doc;
      t_doc.session_id = t_doc.schedule_id;

      //if this type hasn't been seen before, add it to the types Array
      if(!types.includes(t_doc.type))
        types.push(t_doc.type);

      t_doc.type_code = t_doc.type.toLowerCase().replace(" ", "_");


      var dayIndex = -1;
      if(t_doc.day.substring(0, 3) == "Mon") {
        dayIndex = 0;
      }
      if(t_doc.day.substring(0, 3) == "Tue") {
        dayIndex = 1;
      }
      if(t_doc.day.substring(0, 3) == "Wed") {
        dayIndex = 2;
      }
      if(dayIndex != -1)
        sortSession(t_doc, dayIndex);
    }

    //sort sessions by time and by place
    for(var i=0; i<sessions.length; ++i) {
      //sort each day by time
      sessions[i].sort(function(a,b){
        str_timeA = a[0].session_time;
        str_timeB = b[0].session_time;
        return new Date(str_timeA) - new Date(str_timeB);
      });

      timeSlotsWithinThisDay = sessions[i];
      for(var j=0; j<timeSlotsWithinThisDay.length; j++) {
        timeSlotsWithinThisDay[j].sort(function(a,b){
          strA = a.location;
          strB = b.location;
          if(strA < strB) return -1;
          if(strA > strB) return 1;
          return 0;
        });
      }
    }

    // concatenate the smaller slots into 1
    // or append the break to the end of last slots
    thresholdSessionCount = 4
    for(var dayIndex=0; dayIndex<sessions.length; ++dayIndex) {
      timeslots = sessions[dayIndex];
      //put the concatenated timeslots here
      timeslots_new = new Array();

      currentTimeslotIndex = 0;
      while(currentTimeslotIndex < timeslots.length) {
        sub_timeslot = new Array();
        //add the first one, regardless of whether it's above or below the threshold
        do {
          sub_timeslot.push(timeslots[currentTimeslotIndex]);
          ++currentTimeslotIndex;
        }
        while(currentTimeslotIndex < timeslots.length && timeslots[currentTimeslotIndex].length < thresholdSessionCount
         && timeslots[currentTimeslotIndex][0].type_code != "poster"
         && (timeslots[currentTimeslotIndex][0].type_code != "invited_talk" || timeslots[currentTimeslotIndex][0].session_time_start == "09:00 AM")); //this is added so that Posters and Invited Talks are in separate timeslots
        timeslots_new.push(sub_timeslot);
        /*if(timeslots[currentTimeslotIndex].length >= thresholdSessionCount) {
          timeslots_new.push(timeslots[currentTimeslotIndex]);

        }

        while(currentTimeslotIndex < timeslots.length && timeslots[currentTimeslotIndex].length < thresholdSessionCount) {
          timeslots_new.push(timeslots[currentTimeslotIndex]);
          ++currentTimeslotIndex;
        }*/
      }
      sessions[dayIndex] = timeslots_new;
    }

    // populate dailySchedule
    for(var dayIndex=0; dayIndex<sessions.length; ++dayIndex) {
      timeslots = sessions[dayIndex];
      //console.log(timeslots);
      for (var timeslotIndex=0; timeslotIndex<timeslots.length; ++timeslotIndex) {
        str_time = timeslots[timeslotIndex][0][0].session_time;
        time = new Date(str_time);
        str_time_formatted = getFormattedHourMinute(time);
        if(str_time_formatted == "07:00") {
          str_time_formatted = "09:00";
        }
        dailySchedule[dayIndex].slots.push(str_time_formatted);
        /*str_time_formatted = timeslots[timeslotIndex][0][0].session_time_start;
        if(str_time_formatted == "07:00 AM") {
          str_time_formatted = "09:00 AM";
        }
        dailySchedule[dayIndex].slots.push(str_time_formatted);*/
      }
    }

    // create a sesiionid to index mapping sessionIdToIndexMapping
    for(var dayIndex=0; dayIndex<sessions.length; ++dayIndex) {
      timeslots = sessions[dayIndex];
      for (var timeslotIndex=0; timeslotIndex<timeslots.length; ++timeslotIndex) {
        subtimeslots = timeslots[timeslotIndex];
        for (var subtimeslotIndex=0; subtimeslotIndex<subtimeslots.length; ++subtimeslotIndex) {
          sessionsInThisSubTimeSlot = subtimeslots[subtimeslotIndex];
          if(sessionsInThisSubTimeSlot==undefined) {
            var fdgd = 4;
          }
          for(var h=0; h<sessionsInThisSubTimeSlot.length; ++h) {
            t_session = sessionsInThisSubTimeSlot[h];
            t_session_id = t_session.schedule_id;
            sessionIdToIndexMapping[t_session_id] = {"dayIndex" : dayIndex, "timeslotIndex": timeslotIndex, "subtimeslotIndex":subtimeslotIndex, "sub_index": h};
          }
        }
      }
    }
    console.log(allSessionDocs);
  }).catch(function (err) {
    console.log(err);
  });

  function transformItem(oldItem) {
    var newItem = new Object();
    newItem.id = oldItem.paper_id;
    newItem.title = oldItem.title;
    newItem.description = oldItem.abstract;
    newItem.authors = oldItem.authors;
    newItem.authorIds = null; //currently unavailable
    newItem.pdf_url = oldItem.pdf_url;

    if(oldItem.poster_schedule != null && oldItem.poster_schedule != undefined
      && oldItem.poster_schedule.length == 1) {
        newItem.poster_session = oldItem.poster_schedule[0];
    }
    if(oldItem.talk_schedule != null && oldItem.talk_schedule != undefined
      && oldItem.talk_schedule.length == 1) {
        newItem.talk_session = oldItem.talk_schedule[0];
    }
    return newItem;
  }

  itemsDb.allDocs({
      include_docs: true,
      attachments: true
    }).then(function (result) {
      allOldItems = result.rows;
      console.log(allOldItems);

      for (var property in allOldItems) {
        if (!allOldItems.hasOwnProperty(property)) {
          continue;
        }
        newItem = transformItem(allOldItems[property].doc);

        /*add authorsString*/
        if(newItem.authors != undefined && newItem.authors != null) {
          if(typeof(newItem.authors) == "string") {
            console.log("WAAAA?!");
            console.log(newItem);
          }
          newItem.authorsString = newItem.authors.join(", ");
          //console.log("HERE IS THE FUCKING NEW AUTHORSSTRING:");
          //console.log(newItem.authorsString);
        }
        else {
          newItem.authorString = "";
        }

        items[newItem.id] = newItem;
      }
    }).catch(function (err) {
      console.log(err);
    });


    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    async function demo() {
      await sleep(5000);
      scheduleDb.put({
        _id: 'schedule_icml2017',
        sessions: sessions,
        dailySchedule: dailySchedule,
        items: items,
        sessionIdToIndexMapping: sessionIdToIndexMapping

      });
      console.log("done");
    }

//demo();
</script>
</html>
